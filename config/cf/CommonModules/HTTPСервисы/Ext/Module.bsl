
#Область ПрограммныйИнтерфейс

#Область ЛичныйКабинет

// Главная функция личного кабинета. Все запросы POST и GET выполняются здесь.
//
// Параметры:
//	Запрос - HTTPСервисЗапрос - запрос HTTP.
//
// Возвращаемое значение:
//	HTTPСервисОтвет - ответ HTTP.
//
Функция ОбработкаЗапроса(Запрос, ЭтоPOST = Ложь) Экспорт
	
	Перем Ответ;	
	
	// СтандартныеПодсистемы.ОценкаПроизводительности
	ЗначениеТаймера = ЗначениеТаймера();
	// Конец СтандартныеПодсистемы.ОценкаПроизводительности	
	
	УстановитьПривилегированныйРежим(Истина);
	
	Отладка				= Ложь; // << Позволяет заниматься отладкой личного кабинета.
	
	ОтносительныйURL 	= СокрЛП(НРег(Запрос.ОтносительныйURL));
	ИмяФайла 			= Сред(ОтносительныйURL, СтрНайти(ОтносительныйURL, "/", НаправлениеПоиска.СКонца) + 1);
	Путь 				= Лев(ОтносительныйURL, СтрДлина(ОтносительныйURL) - СтрДлина(ИмяФайла));
	БазовыйURL 			= Запрос.БазовыйURL;
	POST 				= Новый Структура();
	ПараметрыЗапроса	= Новый Структура();
	Для Каждого Параметр Из Запрос.ПараметрыЗапроса Цикл
		ПараметрыЗапроса.Вставить(Параметр.Ключ, Параметр.Значение);	
	КонецЦикла;
	
	Если ЭтоPOST Тогда
		
		ДвоичныеДанные	= Запрос.ПолучитьТелоКакДвоичныеДанные();
		Попытка
			Токен = СокрЛП(СтрПолучитьСтроку(Запрос.ПолучитьТелоКакСтроку(), 1));
			POST = РазобратьКонтентHTML(ДвоичныеДанные, Токен);
			Для Каждого Параметр Из POST Цикл
				ПараметрыЗапроса.Вставить(Параметр.Имя, Параметр.Значение);
			КонецЦикла;			
		Исключение
		КонецПопытки;
	
	КонецЕсли;	
	
	ОтносительныйURLПеренаправления	= "";
	
	#Область Предопределенные_Адреса
	
	// Предопределенные элементы, которые нужно обработать
	Если СтрНайти(ОтносительныйURL, НРег("e1cib/data/Справочник.")) > 0 ИЛИ
		СтрНайти(ОтносительныйURL, НРег(".Картинка")) > 0 Тогда
		
		Индекс1 = СтрНайти(ОтносительныйURL, НРег("e1cib/data/Справочник.") );
		Индекс2 = СтрНайти(ОтносительныйURL, ".", НаправлениеПоиска.СКонца);
		ИмяСправочника = Сред(ОтносительныйURL, Индекс1 + СтрДлина("e1cib/data/Справочник."), 
			Индекс2 - Индекс1 - СтрДлина("e1cib/data/Справочник."));
		
		ТекСсылка = НРег(СокрЛП(Запрос.ПараметрыЗапроса.Получить("ref")));
		Если ТекСсылка <> Неопределено И НЕ ПустаяСтрока(ТекСсылка) Тогда
			ТекСсылка = Прав(ТекСсылка, 8)
			   + "-" + Сред(ТекСсылка, 21, 4)
			   + "-" + Сред(ТекСсылка, 17, 4)
			   + "-" + Лев(ТекСсылка, 4)
			   + "-" + Сред(ТекСсылка, 5, 12);
			ТекСсылка = Новый УникальныйИдентификатор(ТекСсылка);
			ТекСсылка = Справочники[ИмяСправочника].ПолучитьСсылку(ТекСсылка);
			Если Лев(""+ТекСсылка, 18) = НСтр("ru = '<Объект не найден>'") Тогда
				ТекСсылка = Неопределено;
			КонецЕсли;
		КонецЕсли;

		Если ТипЗнч(ТекСсылка) = Тип("СправочникСсылка.ФизическиеЛица") Тогда
			ТекФизЛицо = ТекСсылка;
			ДвоичныеДанныеКартинки = Неопределено;
			Если ЗначениеЗаполнено(ТекФизЛицо) И ЗначениеЗаполнено(ТекФизЛицо.ФайлКартинки) Тогда
				ДвоичныеДанныеКартинки = РаботаСФайлами.ДвоичныеДанныеФайла(ТекФизЛицо.ФайлКартинки, Ложь);
			КонецЕсли;
			Если ДвоичныеДанныеКартинки = Неопределено Тогда
				ДвоичныеДанныеКартинки = БиблиотекаКартинок.БазаЗнанийПользователь.ПолучитьДвоичныеДанные();
			КонецЕсли;
			Ответ = Новый HTTPСервисОтвет(200);
			Ответ.Заголовки.Вставить("Access-Control-Allow-Origin", "*");
			Ответ.Заголовки.Вставить("Content-Type", "image/png");
			Ответ.Заголовки.Вставить("Cache-Control", "public, max-age=604800");
			Ответ.УстановитьТелоИзДвоичныхДанных(ДвоичныеДанныеКартинки);
			Возврат Ответ;
		ИначеЕсли ТипЗнч(ТекСсылка) = Тип("СправочникСсылка.ЭтапыПроцессов") Тогда
			ТекЭтап = ТекСсылка;
			Ответ = Новый HTTPСервисОтвет(200);
			Ответ.Заголовки.Вставить("Access-Control-Allow-Origin", "*");
			Ответ.Заголовки.Вставить("Content-Type", "image/png");
			Ответ.Заголовки.Вставить("Cache-Control", "public, max-age=604800");
			Картинка = ТекЭтап.Картинка.Получить();
			Ответ.УстановитьТелоИзДвоичныхДанных(Картинка.ПолучитьДвоичныеДанные());
			Возврат Ответ;
		КонецЕсли;
		
	КонецЕсли;
	
	#КонецОбласти
	
	ЯзыковыеДанные 				= ЯзыковыеДанныеЛичногоКабинета();	
	Страница 					= HTTPСервисыПовтИсп.ПолучитьСтраницуОтносительногоURL(Путь, ИмяФайла);
	СтруктураСтраницы 			= Неопределено;	
	КодОтвета					= 200;
	
	// Используется собственная авторизация?
	// Авторизуем пользователя по логину и паролю.
	Если HTTPСервисыПовтИсп.ПолучитьКонстанту("ЛичныйКабинетИспользоватьСобственнуюАвторизацию") = Истина Тогда
		ТекущийПользователь		 = ПолучитьАвторизованногоПользователя(Запрос.Заголовки);
		
		// Проверка авторизации.
		Если НЕ ЗначениеЗаполнено(ТекущийПользователь) Тогда		
			СтраницаАвторизации = HTTPСервисыПовтИсп.ПолучитьКонстанту("ЛичныйКабинетСтраницаАвторизации");
			Если НЕ ЗначениеЗаполнено(СтраницаАвторизации) Тогда
				Ответ = Новый HTTPСервисОтвет(401); // 401 Unauthorized
				ТипФайла = СокрЛП("text/html; charset=utf-8");
				Ответ.УстановитьТелоИзСтроки(
					СобратьСтраницу(НСтр("ru = 'В настройках личного кабинета не задана страница авторизации'"), 
						НСтр("ru = 'Ошибка 401'")),
					КодировкаТекста.UTF8);
				Возврат Ответ;
			КонецЕсли;
			
			Если Страница.НеПроверятьАвторизацию = Ложь Тогда			
				Страница = СтраницаАвторизации;
			КонецЕсли;
			
		Иначе	
			ПараметрыСеанса.ТекущийПользователь = ТекущийПользователь;		
			
		КонецЕсли;
		
	КонецЕсли;
		
	// Если страница не найдена.
	Если Страница = Неопределено Тогда
		КодОтвета = 404;
		Страница = HTTPСервисыПовтИсп.ПолучитьКонстанту("ЛичныйКабинетСтраница404");
		Если НЕ ЗначениеЗаполнено(Страница) Тогда
			Ответ = Новый HTTPСервисОтвет(404); // 404 Not Found
			ТипФайла = СокрЛП("text/html; charset=utf-8");
			Ответ.УстановитьТелоИзСтроки(
				СобратьСтраницу(НСтр("ru = 'Ошибка 404. Страница не найдена'"), НСтр("ru = 'Ошибка 404'")),
				КодировкаТекста.UTF8);
			Возврат Ответ;
		КонецЕсли;
	КонецЕсли;
	
	СтруктураСтраницы = ?(Отладка = Истина,
		СтруктураСтраницы(Страница), 
		HTTPСервисыПовтИсп.СтруктураСтраницы(Страница));
		
	Ответ = Новый HTTPСервисОтвет(КодОтвета);
	Ответ.Заголовки.Вставить("Access-Control-Allow-Origin", "*");
			
	ТипФайла = СокрЛП(СтруктураСтраницы.ТипФайла);
	Если НРег(ТипФайла) = "text/html" Тогда
		 ТипФайла = "text/html; charset=utf-8";		 
	КонецЕсли;
	Ответ.Заголовки.Вставить("Content-Type", ТипФайла);
	
	// Кэширование файлов браузером.
	Если СтруктураСтраницы.Кэширование = Истина Тогда
		Ответ.Заголовки.Вставить("Cache-Control", 
			"public, max-age=" + Формат(СтруктураСтраницы.ВремяКэширования, "ЧРД=; ЧРГ=; ЧН=0; ЧГ="));
	КонецЕсли;
	
	Данные = СтруктураСтраницы.ХранилищеФайла.Получить(); 
	Переменные = Новый Структура;
	Переменные.Вставить("БазовыйURL", 	БазовыйURL);
	Переменные.Вставить("BASE_URL", 	БазовыйURL);	
	
	Если СтрНайти(НРег(ТипФайла), "text/") = 0 Тогда
		
		Если ПустаяСтрока(СтруктураСтраницы.Алгоритм) Тогда
			
			Ответ.УстановитьТелоИзДвоичныхДанных(Данные);
			
		Иначе
			
			ИмяФайлаТела 	= Неопределено;
			Тело 			= Неопределено;
			ВыполнитьАлгоритм(Тело, ИмяФайлаТела, Переменные, Запрос, Ответ, ОтносительныйURL, 
				ОтносительныйURLПеренаправления, ИмяФайла, Путь, СтруктураСтраницы.Алгоритм, ЯзыковыеДанные, ЭтоPOST,
				POST);
				
			Если Тело <> Неопределено Тогда
				Если ТипЗнч(Тело) = Тип("ДвоичныеДанные") Тогда 
					Ответ.УстановитьТелоИзДвоичныхДанных(Тело);
				Иначе
					Ответ.УстановитьТелоИзСтроки(Тело, КодировкаТекста.UTF8);
				КонецЕсли;
			КонецЕсли;                 
			Если ИмяФайлаТела <> Неопределено Тогда
				Ответ.Заголовки.Вставить("Content-Disposition", "attachment; filename=""" 
					+ КодироватьСтроку(ИмяФайлаТела, СпособКодированияСтроки.КодировкаURL) + """");
			КонецЕсли;
			                  
		КонецЕсли;
		
	Иначе
		
		ИмяФайлаТела = Неопределено;
		Тело = РаботаСHTML.ПолучитьТекстИзДвоичныхДанных(Данные);
				
		// Замена конструкций вида <!---include(...)--->
		ОткрытыйТег = "<!---include(";
		ЗакрытыйТег = ")--->";
		Индекс = СтрНайти(НРег(Тело), ОткрытыйТег);
		Пока Индекс > 0 Цикл
			
			// Находим )--->
			Индекс2 = СтрНайти(НРег(Тело), ЗакрытыйТег);
			Если Индекс2 = 0 Тогда
				Прервать;
			КонецЕсли;
			Стр = Сред(Тело, Индекс + СтрДлина(ОткрытыйТег), Индекс2 - Индекс - СтрДлина(ОткрытыйТег));
			Если СтрНайти(Стр, "/") = 0 Тогда
				Стр = "/" + Стр;
			КонецЕсли;
			Стр = СтрЗаменить(Стр, """", "");
			Стр = СтрЗаменить(Стр, "'", "");
			ИмяФайлаТега = Сред(Стр, СтрНайти(Стр, "/", НаправлениеПоиска.СКонца) + 1);
			ПутьТега = Лев(Стр, СтрДлина(Стр) - СтрДлина(ИмяФайлаТега));

			СтраницаТега = HTTPСервисыПовтИсп.ПолучитьСтраницуОтносительногоURL(ПутьТега, ИмяФайлаТега);
			Если СтраницаТега <> Неопределено Тогда
				СтруктураСтраницыТега = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(СтраницаТега, 
					"ТипФайла, Алгоритм, ХранилищеФайла");
				СтруктураСтраницыТега.Вставить("Алгоритм", СтруктураСтраницыТега.Алгоритм.Получить());
				
				ДанныеТега = СтруктураСтраницыТега.ХранилищеФайла.Получить(); 
				ТелоТега = РаботаСHTML.ПолучитьТекстИзДвоичныхДанных(ДанныеТега);
				ВыполнитьАлгоритм(ТелоТега, ИмяФайлаТела, Переменные, Запрос, Ответ, ОтносительныйURL,
					ОтносительныйURLПеренаправления, ИмяФайла, Путь, СтруктураСтраницыТега.Алгоритм, ЯзыковыеДанные, 
					ЭтоPOST, POST);
					
			Иначе
				ТелоТега = СтрШаблон(НСтр("ru = '<font color=""red"">%1 ""%2""</font>'"), 
					НСтр("ru = 'Не найден файл'"),	Стр);
				
			КонецЕсли;
			
			Тело = Лев(Тело, Индекс - 1) + ТелоТега + Сред(Тело, Индекс2 + СтрДлина(ЗакрытыйТег));
			Индекс = СтрНайти(НРег(Тело), ОткрытыйТег, , Индекс + 1);
			
		КонецЦикла;
		
		// Надо нормальными сделать переменные (чтобы не содержали спец символов HTML).
		Для Каждого Стр Из Переменные Цикл
			Если ТипЗнч(Стр.Значение) = Тип("Строка") Тогда
				Переменные[Стр.Ключ] = СтрЗаменить(Переменные[Стр.Ключ], "<", "&lt;");
				Переменные[Стр.Ключ] = СтрЗаменить(Переменные[Стр.Ключ], ">", "&gt;");
			КонецЕсли;
		КонецЦикла;
		
		// Выполнить алгоритм
		ВыполнитьАлгоритм(Тело, ИмяФайлаТела, Переменные, Запрос, Ответ, ОтносительныйURL, 
			ОтносительныйURLПеренаправления, ИмяФайла, Путь, СтруктураСтраницы.Алгоритм, ЯзыковыеДанные, 
			ЭтоPOST, POST); 
		
		// Подставим переменные.
		ОткрытыйТег = "<!---";
		ЗакрытыйТег = "--->";
		Индекс = СтрНайти(НРег(Тело), ОткрытыйТег);
		Пока Индекс > 0 Цикл
			
			// Находим --->
			Индекс2 = СтрНайти(НРег(Тело), ЗакрытыйТег);
			Если Индекс2 = 0 Тогда
				Прервать;
			КонецЕсли;
			Стр = Сред(Тело, Индекс + СтрДлина(ОткрытыйТег), Индекс2 - Индекс - СтрДлина(ОткрытыйТег));
			Стр = СокрЛП(Стр);
			Тег = "";
			// Есть в переменных?
			Если НЕ Переменные.Свойство(Стр, Тег) Тогда
				// Если нет в переменных, есть ли в языковых данных?
				Если НЕ ЯзыковыеДанные.Свойство(Стр, Тег) Тогда
					Тег = СтрШаблон(НСтр("ru = '<font color=""red"">Не найдена переменная ""%1""</font>'"), Стр);
				КонецЕсли;				
			КонецЕсли;			
			Тело = Лев(Тело, Индекс - 1) + Тег + Сред(Тело, Индекс2 + СтрДлина(ЗакрытыйТег));
			Индекс = СтрНайти(НРег(Тело), ОткрытыйТег, НаправлениеПоиска.СНачала, Индекс+1);
		КонецЦикла;
		
		// Перенаправляем на другую страницу.
		// Тут надо быть внимательным, чтобы не было рекурсии.
		Если НЕ ПустаяСтрока(ОтносительныйURLПеренаправления) Тогда
			Ответ = Новый HTTPСервисОтвет(302);
			Ответ.Заголовки.Очистить();
			НовыйURL = СокрЛП(Запрос.БазовыйURL) + "/" + ОтносительныйURLПеренаправления;
			Ответ.Заголовки.Вставить("Location", НовыйURL);
			Ответ.Заголовки.Вставить("Content-Location", НовыйURL);
			Возврат Ответ;
		Иначе
			
			// Проверка на то, что есть системные переменные.
			Если ИмяФайлаТела <> Неопределено Тогда
				Ответ.Заголовки.Вставить("Content-Disposition", "attachment; filename=""" 
					+ КодироватьСтроку(ИмяФайлаТела, СпособКодированияСтроки.КодировкаURL) + """");
			КонецЕсли;
			Ответ.УстановитьТелоИзСтроки(Тело, КодировкаТекста.UTF8);
			
		КонецЕсли;
		
	КонецЕсли;
	
	// СтандартныеПодсистемы.ОценкаПроизводительности
	ЗаписатьЗамер("HttpСервисы", ЗначениеТаймера);
	// Конец СтандартныеПодсистемы.ОценкаПроизводительности
		
	Возврат Ответ;
		
КонецФункции

#КонецОбласти

#Область ВспомогательныеФункции

// Возвращает относительный URL страницы личного кабинета.
//
// Параметры:
//	Страница - СправочникСсылка.СтраницыЛичногоКабинета - страница личного кабинета.
//
// Возвращаемое значение:
//	Строка - URL страницы. Пример folder/script.js (страница script.js находится в папке folder).
//
Функция ОтносительныйURLСтраницы(Знач Страница) Экспорт
	
	Возврат HTTPСервисыПовтИсп.ОтносительныйURLСтраницы(Страница);
	
КонецФункции

// Удаляет из текста теги < и > и возвращает результат.
//
// Параметры:
//	Текст - Строка - исходный текст.
//
// Возвращаемое значение:
//	Строка - результат удаления.
//
Функция ОбработатьТеги(Знач Текст) Экспорт
	
	Возврат РаботаСHTML.ОбработатьТеги(Текст);
	
КонецФункции

// Возвращает алгоритм страницы используя относительный URL.
//
// Параметры:
//	ОтносительныйURL - Строка - адрес URL.
//
// Возвращаемое значение:
//	Строка - алгоритм найденной страницы или пустая строка.
//
Функция АлгоритмСтраницы(Знач ОтносительныйURL) Экспорт
	
	ИмяФайла = Сред(ОтносительныйURL, СтрНайти(ОтносительныйURL, "/", НаправлениеПоиска.СКонца) + 1);
	Путь 	 = Лев(ОтносительныйURL, СтрДлина(ОтносительныйURL) - СтрДлина(ИмяФайла));	
	Страница = HTTPСервисыПовтИсп.ПолучитьСтраницуОтносительногоURL(Путь, ИмяФайла);
	
	Если Страница <> Неопределено Тогда
		Возврат Страница.Алгоритм.Получить();
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

// Возвращает таблицу с параметрами из тела документа.
//
// Параметры:
//	Тело - Строка - исходный HTML-документ с параметрами.
//	ДобавитьВключаемыеОбласти - Булево - в результат будут включены области вида <!---include(file.html)--->
//
// Возвращаемое значение:
// 	ТаблицаЗначений - таблица с колонкой "Параметр".
//	
Функция ПолучитьТаблицуПараметов(Знач Тело, Знач ДобавитьВключаемыеОбласти = Истина) Экспорт
	
	ТаблицаПараметров = Новый ТаблицаЗначений;
	ТаблицаПараметров.Колонки.Добавить("Параметр", Новый ОписаниеТипов("Строка"));
	
	ОткрытыйТег = "<!---";
	ЗакрытыйТег = "--->";
	Индекс = СтрНайти(НРег(Тело), ОткрытыйТег);
	Пока Индекс > 0 Цикл
		
		// Находим --->
		Индекс2 = СтрНайти(НРег(Тело), ЗакрытыйТег);
		Если Индекс2 = 0 Тогда
			Прервать;
		КонецЕсли;
		Стр = Сред(Тело, Индекс + СтрДлина(ОткрытыйТег), Индекс2 - Индекс - СтрДлина(ОткрытыйТег));
		Стр = СокрЛП(Стр);
		Тег = "";		
		Тело = Лев(Тело, Индекс - 1) + Тег + Сред(Тело, Индекс2 + СтрДлина(ЗакрытыйТег));
		
		ДобавлятьПараметр = Истина;
		Если ДобавитьВключаемыеОбласти = Ложь Тогда
			Если СтрНайти(НРег(Стр), "include(") > 0 Тогда
				ДобавлятьПараметр = Ложь;
			КонецЕсли;
		КонецЕсли;
		
		Если ДобавлятьПараметр Тогда
			Строка = ТаблицаПараметров.Добавить();
			Строка.Параметр = Стр;
		КонецЕсли;
		
		Попытка
			Индекс = СтрНайти(НРег(Тело), ОткрытыйТег, НаправлениеПоиска.СНачала, Индекс + 1);
		Исключение
			Прервать;
		КонецПопытки;
		
	КонецЦикла;

	ТаблицаПараметров.Свернуть("Параметр", );
	ТаблицаПараметров.Сортировать("Параметр");

	Возврат ТаблицаПараметров;
	
КонецФункции

// Получает данные страницы личного кабинета.
//
// Параметры:
// 	Страница - СправочникСсылка.ЛичныйКабинет - страница личного кабинета.
//
// Возвращаемое значение:
// 	Структура - результат настроек страницы
// 		* ТипФайла - Строка - тип с файлом страницы.
// 		* Алгоритм - Строка - алгоритм для страницы.
// 		* ХранилищеФайла - ХранилищеЗначения - в чем хранится файл.
// 		* Кэширование - Булево - страница кэшируется или нет.
// 		* ВремяКэширования - Число - срок кэширования в секундах.
// 		* НеПроверятьАвторизацию - Булево - проверять авторизацию у страницы или нет.   
//
Функция СтруктураСтраницы(Знач Страница) Экспорт
	
	Результат = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Страница, 
		"ТипФайла, Алгоритм, ХранилищеФайла, Кэширование, ВремяКэширования, НеПроверятьАвторизацию");
	Результат.Вставить("Алгоритм", Результат.Алгоритм.Получить());	
	
	Возврат Результат;
    
КонецФункции

#КонецОбласти

#Область Работа_с_URL

// Разбирает строку URI на составные части и возвращает в виде структуры.
// На основе RFC 3986.
//
// Параметры:
//  СтрокаURI - Строка - ссылка на ресурс в формате:
//                       <схема>://<логин>:<пароль>@<хост>:<порт>/<путь>?<параметры>#<якорь>.
//
// Возвращаемое значение:
//  Структура - составные части URI согласно формату:
//   * Схема         - Строка - схема из URI.
//   * Логин         - Строка - логин из URI.
//   * Пароль        - Строка - пароль из URI.
//   * ИмяСервера    - Строка - часть <хост>:<порт> из URI.
//   * Хост          - Строка - хост из URI.
//   * Порт          - Строка - порт из URI.
//   * ПутьНаСервере - Строка - часть <путь>?<параметры>#<якорь> из URI.
//
Функция СтруктураURI(Знач СтрокаURI) Экспорт
    
    Возврат РаботаСHTML.СтруктураURI(СтрокаURI);
	
КонецФункции

// Находит в справочнике "ЛичныйКабинет" элемент в нужной иерархии папок 
// 	и для данного элемента.
//
// Параметры:
//	Путь - Строка - исходный путь.
//	ИмяФайла - Строка - имя файла.
//
// Возвращаемое значение:
//	СправочникСсылка.ЛичныйКабинет - найденная страница, либо Неопределено.
//
Функция ПолучитьСтраницуОтносительногоURL(Знач Путь, Знач ИмяФайла) Экспорт
	
	Возврат HTTPСервисыПовтИсп.ПолучитьСтраницуОтносительногоURL(Путь, ИмяФайла);

КонецФункции

// Определить MIME-тип файла по его имени.
//
// Параметры:
//	ИмяФайла - Строка - имя файла.
//
// Возвращаемое значение:
//	Строка - MIME-тип.
//
Функция ОпределитьТипФайла(Знач ИмяФайла) Экспорт
	
    Возврат РаботаСHTML.ТипФайла(ИмяФайла);
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область Кодировки

// Функции по преобразованию Base <=> Текстовая строка
Процедура УдалитьПрефиксUTF(Строка64)
	
	Если Лев(Строка64, 4) = "77u/" Тогда 
		Строка64 = Сред(Строка64, 5);
	КонецЕсли;
	
КонецПроцедуры

Функция Строка64ВСтроку(Знач Строка64)
	
	Если Лев(Строка64, 4) = "77u/" Тогда 
		Строка64 = Сред(Строка64, 5); 
	КонецЕсли;
	                    
	Массив64 = Новый Массив;
	Для Код = КодСимвола("A") По КодСимвола("Z") Цикл 
		Массив64.Добавить(Символ(Код)); 
	КонецЦикла;
	Для Код = КодСимвола("a") По КодСимвола("z") Цикл 
		Массив64.Добавить(Символ(Код)); 
	КонецЦикла;
	Для Код = КодСимвола("0") По КодСимвола("9") Цикл 
		Массив64.Добавить(Символ(Код)); 
	КонецЦикла;
	Массив64.Добавить("+");
	Массив64.Добавить("/");
	
	МассивВрем = Новый Массив;
	
	Строка64 = СтрЗаменить(СтрЗаменить(Строка64, Символ(13), ""), Символ(10), "");

	Количество4 = Цел(СтрДлина(Строка64) / 4);
	Рет 		= "";
	Загрушек 	= 0;
	Для Индекс4 = 0 По Количество4 - 1 Цикл
		Накопитель = 0;
		Для Индекс = 0 По 3 Цикл
			Символ = Сред(Строка64, Индекс4 * 4 + 1 + Индекс, 1);
			Если Символ = "=" Тогда 
				Загрушек = Загрушек + 1;
				Накопитель = Накопитель * 64;
				Продолжить;
			КонецЕсли;
			
			ИндексЭлемента = Массив64.Найти(Символ);
			Накопитель = Накопитель * 64 + ИндексЭлемента;
		КонецЦикла;
		
		Для Индекс3 = - 2 По 0 Цикл
			Остаток = Накопитель % 256;
			Если МассивВрем.ВГраница() >= Индекс4 * 3 - Индекс3 Тогда
				МассивВрем[Индекс4 * 3 - Индекс3] = Остаток;
			Иначе
				МассивВрем.Вставить(Индекс4 * 3 - Индекс3, Остаток);
			КонецЕсли;
			Накопитель = (Накопитель - Остаток) / 256;
		КонецЦикла;
	КонецЦикла;
		
	КоличествоЭлементов = МассивВрем.Количество() - Загрушек;
	Индекс = 0;
	Пока Индекс < КоличествоЭлементов Цикл
		Если Индекс + 3 < КоличествоЭлементов И МассивВрем[Индекс] >= 240 И МассивВрем[Индекс + 1] >= 128 
			И МассивВрем[Индекс + 2] >= 128 И МассивВрем[Индекс + 3] >= 128 Тогда
			Рет = Рет + Символ(64 * 64 * 64 *(МассивВрем[Индекс] - 240) + 64 * 64 *(МассивВрем[Индекс + 1]) - 128 
				+ 64 * (МассивВрем[Индекс + 2] - 128) + МассивВрем[Индекс + 3] - 128);
			Индекс = Индекс + 4;
			Продолжить;
			
		ИначеЕсли Индекс + 2 < КоличествоЭлементов И МассивВрем[Индекс] >= 224 И МассивВрем[Индекс + 1] >= 128 
			И МассивВрем[Индекс + 2] >= 128 Тогда
			Рет = Рет + Символ(64 * 64 * (МассивВрем[Индекс] - 224) + 64 * (МассивВрем[Индекс + 1] - 128) 
				+ МассивВрем[Индекс + 2] - 128);
			Индекс = Индекс + 3;
			Продолжить;
			
		ИначеЕсли Индекс + 1 < КоличествоЭлементов И МассивВрем[Индекс] >= 192 И МассивВрем[Индекс + 1] >= 128 Тогда
			Рет = Рет + Символ(64 * (МассивВрем[Индекс] - 192) + МассивВрем[Индекс + 1] - 128);
			Индекс = Индекс + 2;
			Продолжить;
			
		Иначе	
			Рет = Рет + Символ(МассивВрем[Индекс]);
			Индекс = Индекс + 1;
			Продолжить;
			
		КонецЕсли;
	КонецЦикла;
	Рет = СтрЗаменить(Рет, Символы.ВК + Символы.ПС, Символы.ПС);
	
	Возврат Рет;
	
КонецФункции

// Преобразует символ в юникод.
//
// Параметры:
//	Символ - Строка - символ.
//
// Возвращаемое значение:
//	Строка - в формате юникод.
//
Функция ПреобразоватьСимволЮникод(Знач Символ)
	
	Код = КодСимвола(Символ);
	
	Если Код >= 2048 Тогда
		КоличествоБайт = 2;
		Байты = Новый Массив; Байты.Добавить(224); Байты.Добавить(128); Байты.Добавить(128);
	ИначеЕсли Код >= 128 Тогда
		КоличествоБайт = 1;
		Байты = Новый Массив; Байты.Добавить(192); Байты.Добавить(128); 
	Иначе
		Байты = Новый Массив; Байты.Добавить(Код);
		Возврат Байты;
	КонецЕсли;	
	
	Для ИндексБайт = - КоличествоБайт По 0 Цикл
		Остаток = (Код % 64);
		Байты[- ИндексБайт] = Байты[- ИндексБайт] + Остаток;
		Код = (Код - Остаток) / 64;
	КонецЦикла;
	
    Возврат Байты;
	
КонецФункции

Функция СтрокаВСтроку64(Знач СтрокаСимволов)
	
	Массив64 = Новый Массив;
	
	Для Код = КодСимвола("A") По КодСимвола("Z") Цикл 
		Массив64.Добавить(Символ(Код)); 
	КонецЦикла;
	Для Код = КодСимвола("a") По КодСимвола("z") Цикл 
		Массив64.Добавить(Символ(Код)); 
	КонецЦикла;
	Для Код = КодСимвола("0") По КодСимвола("9") Цикл 
		Массив64.Добавить(Символ(Код)); 
	КонецЦикла;
	Массив64.Добавить("+");
	Массив64.Добавить("/");

	Рет = "";   
	РетХ = "";
	СтрокаСимволов = СтрЗаменить(СтрокаСимволов, Символы.ПС, Символы.ВК + Символы.ПС);
	КоличествоСимволов = СтрДлина(СтрокаСимволов);
	
	КоличествоУчтенных = 0;
	Накопитель = 0;
	Для Индекс = 0 По КоличествоСимволов - 1 Цикл
		МассивВрем = ПреобразоватьСимволЮникод(Сред(СтрокаСимволов, Индекс + 1, 1));
		
		Для ИндексВ = 0 По МассивВрем.Количество() - 1 Цикл
			Накопитель = Накопитель * 256 + МассивВрем[ИндексВ];
			Если КоличествоУчтенных = 2 ИЛИ (Индекс = КоличествоСимволов - 1 
				И ИндексВ = МассивВрем.Количество() - 1) Тогда
				Пока КоличествоУчтенных < 2 Цикл 
					Накопитель = Накопитель * 256; 
					КоличествоУчтенных = КоличествоУчтенных + 1; 
					РетХ = РетХ + "="; 
				КонецЦикла;
				МассивГрупп = Новый Массив(4);
				Для Индекс4 = -3 По 0 Цикл
					Остаток = Накопитель % 64;
					Накопитель = (Накопитель - Остаток) / 64;
					МассивГрупп[ - Индекс4] = Остаток;
				КонецЦикла;
				Для Индекс4 = 0 По 3 Цикл 
					Рет = Рет + Массив64[МассивГрупп[Индекс4]];
				КонецЦикла;	
				КоличествоУчтенных = 0;
			Иначе
				КоличествоУчтенных = КоличествоУчтенных + 1;
			КонецЕсли
		КонецЦикла;
	КонецЦикла;
	
	Возврат "77u/" + ?(ЗначениеЗаполнено(РетХ), Лев(Рет, СтрДлина(Рет) - СтрДлина(РетХ)) + РетХ, Рет);
	
КонецФункции

// Из структуры POST по ключу найти значение.
//
// Параметры:
//	POST - Структура - исходная структура.
//	Ключ - Строка - ключ в структуре.
//
// Возвращаемое значение:
//	Произвольные - значение по ключу.
//
//@skip-warning
Функция ЗначениеPOST(Знач POST, Знач Ключ)
	
	нКлюч = НРег(СокрЛП(Ключ));
	
	Для Каждого Структура Из POST Цикл
		Если НРег(СокрЛП(Структура.Имя)) = нКлюч Тогда
			Возврат Структура.Значение;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

// Из структуры POST по ключу найти имя файла.
//
// Параметры:
//	POST - Структура - исходная структура.
//	Ключ - Строка - ключ в структуре.
//
// Возвращаемое значение:
//	Произвольные - имя файла по ключу.
//
//@skip-warning
Функция ИмяФайлаPOST(Знач POST, Знач Ключ)
	
	нКлюч = НРег(СокрЛП(Ключ));
	
	Для Каждого Структура Из POST Цикл
		Если НРег(СокрЛП(Структура.Имя)) = нКлюч Тогда
			Возврат Структура.ИмяФайла;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

//Возвращает строку - кодированные по Base64 данные, представленные массивом байт
Функция КодироватьБ64(Знач Данные)
    
	Б64т = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    
	Б64м = Новый Массив(64);
	Для НН = 0 По 63 Цикл
		Б64м[НН] = Сред(Б64т, НН + 1, 1);
	КонецЦикла;
	Рез = "";
	Кол = Данные.Количество();
	Для НН = 0 По Цел(Кол / 3) - 1 цикл
		Рез = Рез + Б64м[Цел(Данные[НН * 3] / 4)]                                          
		  + Б64м[(Данные[НН * 3] % 4) * 16 + Цел(Данные[НН * 3 + 1] / 16)]
		  + Б64м[(Данные[НН * 3 + 1] % 16) * 4 + Цел(Данные[НН * 3 + 2] / 64)]
		  + Б64м[(Данные[НН * 3 + 2] % 64)];
      КонецЦикла;
      
    о = Кол % 3;
	Если о > 0 тогда
		НН = Цел(Кол / 3) * 3;
		ч1 = Данные[НН];
		ч2 = ?(о > 1, Данные[НН+1], 0);
		Рез = Рез + Б64м[Цел(ч1 / 4)] + Б64м[(ч1 % 4) * 16 + Цел(ч2 / 16)];
		Если о = 1 тогда
			Рез = Рез + "==";
		Иначе
			Рез = Рез + Б64м[(ч2 % 16) * 4] + "=";
		КонецЕсли;
    КонецЕсли;
    
	Возврат Рез;
    
КонецФункции

//Возвращает массив чисел - байт, декодированных из Base64 строки
Функция ДекодироватьБ64(Знач ИсходнаяСтрока)
    
	Б64т = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	Б64м = Новый Массив(64);
	Для НН = 0 По 63 Цикл
		Б64м[НН] = Сред(Б64т, НН + 1, 1);
    КонецЦикла;
    
	Рез = Новый Массив;
	Для СтрИ = 1 По СтрЧислоСтрок(ИсходнаяСтрока) Цикл
		стр = СтрПолучитьСтроку(ИсходнаяСтрока, СтрИ);
		Для Н = 1 По Цел(СтрДлина(стр) / 4) Цикл
			с1 = Сред(стр,(Н-1) * 4 + 1, 1);
			с2 = Сред(стр,(Н-1) * 4 + 2, 1);
			с3 = Сред(стр,(Н-1) * 4 + 3, 1);
			с4 = Сред(стр,(Н-1) * 4 + 4, 1);
			к1 = СтрНайти(Б64т, с1) - 1;
			к2 = СтрНайти(Б64т, с2) - 1;
			к3 = СтрНайти(Б64т, с3) - 1;
			к4 = СтрНайти(Б64т, с4) - 1;
			Если к1 < 0 ИЛИ к2 < 0 тогда
				Возврат рез;
			КонецЕсли;
			Рез.Добавить(к1 * 4 + Цел(к2 / 16));
			Если к3 >= 0 тогда
				Рез.Добавить((к2 % 16) * 16 + Цел(к3 / 4));
			Иначе
				Возврат Рез;
			КонецЕсли;
			Если к4 >= 0 тогда
				Рез.Добавить((к3 % 4) * 64 + к4);
			Иначе
				Возврат Рез;
			КонецЕсли;
        КонецЦикла;
        
		Если СтрДлина(стр) % 4 > 0 Тогда
			Прервать;
        КонецЕсли;
        
    КонецЦикла;
    
	Возврат Рез;
    
КонецФункции

#КонецОбласти

#Область ДляОбработкиПолученияМультиданныхPOST

Функция ПолучитьТокен64(Знач Токен, Хвост = 0)
	
	СтрДл = СтрДлина(Токен);
	Хвост = СтрДл % 3;
	СтрДл = СтрДл - Хвост;
	Ответ = СтрокаВСтроку64(Лев(Токен, СтрДл));
	УдалитьПрефиксUTF(Ответ);
	
	Возврат Ответ;
	
КонецФункции

Функция ПолучитьИнфоПоКонтенту(Знач тЗаголовок) 
	
	//Content-Disposition: form-data; name="comment"
	//Content-Disposition: form-data; name="upload1"; filename="IMG_20150108_163648.jpg"
	//Content-Type: image/jpeg
	
	Ответ = Новый Соответствие;
    
	Для сч1 = 1 по СтрЧислоСтрок(тЗаголовок) Цикл
		тСтр1 = СтрЗаменить(СокрЛП(СтрПолучитьСтроку(тЗаголовок, сч1)), ";", Символы.ПС);
		Для сч2 = 1 по СтрЧислоСтрок(тСтр1) Цикл
			тСтр = СокрЛП(СтрПолучитьСтроку(тСтр1, сч2));
			Если Лев(НРег(тСтр), 13) = "content-type:" Тогда
				Ответ.Вставить("content-type", СокрЛ(Сред(тСтр, 14)));
				Продолжить;
			КонецЕсли;
			П = СтрНайти(тСтр, "=");
			Если П > 0 Тогда
				ТекЗнач = СокрЛП(Сред(тСтр, П+1));
				Если Лев(ТекЗнач, 1) = """" И Прав(ТекЗнач, 1) = """" Тогда
					ТекЗнач = Сред(ТекЗнач, 2, СтрДлина(ТекЗнач)-2);
				КонецЕсли;
				Ответ.Вставить(НРег(СокрЛП(Лев(тСтр, П - 1))), ТекЗнач);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	Возврат Ответ;
	
КонецФункции

// Возвращает массив структур (Тип,Имя,ИмяФайла,Значение)
Функция РазобратьКонтентHTML(ДД, Знач Токен) 
	
	Ответ = Новый Массив;
	
	Данные = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Base64Строка(ДД), Символы.ПС, ""), Символы.ВК, ""), 
		Символы.ПФ, ""), Символы.Таб, "");
	УдалитьПрефиксUTF(Данные);	
	
	Токен1 		 = ПолучитьТокен64(Токен);
	Токен2 		 = ПолучитьТокен64(Сред(Токен, 2));
	Токен3 		 = ПолучитьТокен64(Сред(Токен, 3));
	ДлинаТокена1 = СтрДлина(Токен1);
	ДлинаТокена2 = СтрДлина(Токен2);
	ДлинаТокена3 = СтрДлина(Токен3);
	
	Предел 		= СтрДлина(Данные);	
	П 			= СтрНайти(Данные, Токен1);
	ДлинаТокена = ДлинаТокена1;
	ПрефиксТокена = 0;
	Пока П > 0 И П < Предел Цикл
		ТекЧасть = Лев(Данные, П-1);
		Данные = Сред(Данные, П + ДлинаТокена);		
		
		Если ТекЧасть<>"" Тогда
			тЗаголовок = Строка64ВСтроку(Лев(ТекЧасть, 1020));
			П = СтрНайти(тЗаголовок, Символы.ПС + Символы.ПС);
			Если П > 0 Тогда
				тЗаголовок 	= Лев(тЗаголовок, П+2);				
				тЗаг 		= СокрЛП(Сред(тЗаголовок, СтрНайти(тЗаголовок, Символы.ПС)+1));				
				ТекИнфо 	= ПолучитьИнфоПоКонтенту(тЗаг);
				тТип 		= ТекИнфо["content-type"]; 
				тТип 		= ?(тТип = Неопределено, "", тТип);
				тФайл 		= ТекИнфо["filename"]; 
				тФайл 		= ?(тФайл = Неопределено, "", тФайл);
				тИмяПоля 	= ТекИнфо["name"]; 
				тИмяПоля 	= ?(тИмяПоля = Неопределено, "", тИмяПоля);
				
				Если (тТип = "" ИЛИ НРег(Лев(тТип, 5)) = "text/") И тФайл = "" Тогда
					Содержимое = Строка64ВСтроку(ТекЧасть);
					Содержимое = Сред(Содержимое, СтрНайти(Содержимое, Символы.ПС + Символы.ПС) + 2);
					Содержимое = Лев(Содержимое, СтрДлина(Содержимое) - ПрефиксТокена);
					Ответ.Добавить(Новый Структура("Тип,Имя,ИмяФайла,Значение", "text", тИмяПоля, тФайл, Содержимое));
				Иначе
					дл64 = 4;
					тЗаголовок = Строка64ВСтроку(Лев(ТекЧасть, дл64));
					П = СтрНайти(тЗаголовок, Символы.ПС+Символы.ПС);
					Пока П=0 И дл64<1000 Цикл
						дл64 = дл64 + 4;
						тЗаголовок = Строка64ВСтроку(Лев(ТекЧасть, дл64));
						П = СтрНайти(тЗаголовок, Символы.ПС + Символы.ПС);
					КонецЦикла;
					П = П + 2;
					Часть1 = ДекодироватьБ64(Прав(Лев(ТекЧасть, дл64), 4));
					Если Часть1.Количество() = 3 Тогда
						Для сч = 0 по 2 Цикл
							Если Часть1[0] = 13 или Часть1[0] = 10 Тогда
								Часть1.Удалить(0);
							Иначе
								Прервать;
							КонецЕсли;
						КонецЦикла;
					Иначе
						Часть1.Очистить();
					КонецЕсли;
					Если Часть1.Количество()=0 Тогда
						Часть1 = Неопределено;
					Иначе
						Часть1 = Base64Значение(КодироватьБ64(Часть1));
					КонецЕсли;
					тТело = Сред(ТекЧасть, дл64+1);
					ДД = Base64Значение(тТело);
					Если ДД <> Неопределено Тогда
						Если Часть1 <> Неопределено Тогда
							ДД = ОбъединитьДвоичныеДаннные(Часть1, ДД);
						КонецЕсли;
						Ответ.Добавить(Новый Структура("Тип, Имя, ИмяФайла, Значение", тТип, тИмяПоля, тФайл, ДД));
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		П1 = СтрНайти(Данные, Токен1);
		П2 = СтрНайти(Данные, Токен2);
		П3 = СтрНайти(Данные, Токен3);
		Если П1 = 0 И П2 = 0 И П3 = 0 Тогда
			Прервать;
		Иначе
			П1 	= ?(П1 = 0, Предел, П1);
			П2 	= ?(П2 = 0, Предел, П2);
			П3 	= ?(П3 = 0, Предел, П3);
			П 	= Мин(П1, П2, П3);
			ДлинаТокена 	= ?(П = П1, ДлинаТокена1, ?(П = П2, ДлинаТокена2, ДлинаТокена3));
			ПрефиксТокена 	= ?(П = П1, 0, ?(П = П2, 1, 2));
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ответ;
	
КонецФункции

//@skip-warning
Функция ВыделитьТекст(Знач ИсходнаяСтрока, Знач Текст)

	Результат = СокрЛП(ИсходнаяСтрока);
	
	ЗапрещенныеСимволы = ".,:;-+/\|" + Символы.НПП + Символы.ВТаб;
	РезультатВрем = Текст;
	Для Индекс = 1 По СтрДлина(ЗапрещенныеСимволы) Цикл
		Пока СтрНайти(РезультатВрем, Сред(ЗапрещенныеСимволы, Индекс, 1)) > 0 Цикл
			РезультатВрем = СтрЗаменить(РезультатВрем, Сред(ЗапрещенныеСимволы, Индекс, 1), " ");
		КонецЦикла;
	КонецЦикла;
	
	Пока СтрНайти(РезультатВрем, "  ") > 0 Цикл
		РезультатВрем = СтрЗаменить(РезультатВрем, "  ", " ");
	КонецЦикла;
	Если НЕ ПустаяСтрока(РезультатВрем) Тогда
		МассивСтрок = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(РезультатВрем, " ", Истина, Истина);
	Иначе
		МассивСтрок = Новый Массив;
		МассивСтрок.Добавить(Текст);
	КонецЕсли;	
	
	ИндексЦвета = 1;
	
	Для Каждого ПодстрокаТекста Из МассивСтрок Цикл
		
		ИндексПоиска = СтрНайти(ВРег(Результат), ВРег(ПодстрокаТекста));
		Пока ИндексПоиска > 0 Цикл
			
			Подстрока = "<span class='bold high" + Формат(ИндексЦвета, "ЧРД=; ЧРГ=; ЧН=0; ЧГ=") + "'>" 
				+ Сред(Результат, ИндексПоиска, СтрДлина(ПодстрокаТекста)) + "</span>";
			Результат = Лев(Результат, ИндексПоиска - 1) 
				+ Подстрока
				+ Сред(Результат, ИндексПоиска + СтрДлина(ПодстрокаТекста));
				
			Если СтрДлина(Результат) > ИндексПоиска + СтрДлина(Подстрока) Тогда
				ИндексПоиска = СтрНайти(ВРег(Результат), ВРег(ПодстрокаТекста), НаправлениеПоиска.СНачала, ИндексПоиска 
					+ СтрДлина(Подстрока));
			Иначе
				ИндексПоиска = 0;
			КонецЕсли;
			
		КонецЦикла;
		
		ИндексЦвета = Мин(ИндексЦвета + 1, 6);
		
	КонецЦикла;
	
	Возврат Результат;

КонецФункции // ВыделитьТекст()

#КонецОбласти

#Область Авторизация

// Выполняет авторизацию по пользователю.
//
// Параметры: 
// 	Логин - Строка - логин пользователя.
// 	Пароль - Строка - пароль пользователя.
//	Запрос - HTTPЗапрос - запрос HTTP.
//	Ответ - HTTPОтвет - ответ HTTP. Ответ возвращается для переадресации.
//	
//@skip-warning
Процедура ВыполнитьАвторизациюПользователя(Знач Логин, Знач Пароль, Знач Запрос, Ответ)
	
	УстановитьПривилегированныйРежим(Истина);
	ПользовательСсылка = НайтиПользователяПоЛогинуИПаролю(Логин, Пароль);
	
	Если НЕ ЗначениеЗаполнено(ПользовательСсылка) Тогда
		Возврат;
	КонецЕсли;
		
	// Удалим устаревшие записи токенов.
	УдалитьУстаревшиеТокеныАвторизации();
	
	// Запишем новый токен для авторизуящегося пользователя.
	Токен 					= Строка(Новый УникальныйИдентификатор);
	Запись 					= РегистрыСведений.ТокеныЛичногоКабинета.СоздатьМенеджерЗаписи();
	Запись.Пользователь		= ПользовательСсылка;
	Запись.Токен			= Токен;
	Запись.СрокЖизниТокена	= ТекущаяДатаСеанса() + ВремяЖизниАвторизацииВСекундах();
	Запись.Записать(Истина);
	
	Ответ = Новый HTTPСервисОтвет(302);
	Ответ.Заголовки.Очистить();

	ОтносительныйURLПеренаправления = Запрос.ОтносительныйURL;
	Если ПустаяСтрока(ОтносительныйURLПеренаправления) Тогда
		ОтносительныйURLПеренаправления = "index.html";
	КонецЕсли;
			 
	Если Прав(СокрЛП(Запрос.БазовыйURL), 1) <> "/" И НЕ ПустаяСтрока(ОтносительныйURLПеренаправления)
		И Лев(СокрЛП(ОтносительныйURLПеренаправления), 1) <> "/" Тогда
		ОтносительныйURLПеренаправления = "/" + СокрЛП(ОтносительныйURLПеренаправления);		
	КонецЕсли;	
	НовыйURL = СокрЛП(Запрос.БазовыйURL) + ОтносительныйURLПеренаправления;
	Ответ.Заголовки.Вставить("Location", 			НовыйURL);
	Ответ.Заголовки.Вставить("Content-Location", 	НовыйURL);	
	Ответ.Заголовки.Вставить("Set-Cookie",			"token=" + Токен + "; Max-Age="
		+ Формат(ВремяЖизниАвторизацииВСекундах(), "ЧРД=; ЧРГ=; ЧГ=0;") + "; HttpOnly; SameSite;");
		
	ОбновитьПовторноИспользуемыеЗначения();
		
КонецПроцедуры

// Удаляет авторизацию по пользователю.
//
// Параметры:
//	Запрос - HTTPЗапрос - запрос HTTP.
//	Ответ - HTTPОтвет - ответ HTTP. Ответ возвращается для переадресации.
//
//@skip-warning
Процедура УдалитьДанныеОбАвторизации(Знач Запрос, Ответ)
	
	УстановитьПривилегированныйРежим(Истина);
	ПользовательСсылка 	= ПолучитьАвторизованногоПользователя(Запрос.Заголовки);
	МассивТокенов 		= ЗначенияCookie(Запрос.Заголовки, "token");
	
	// Удаляем данные из регистра с токенами по пользователю
	Если ЗначениеЗаполнено(ПользовательСсылка) И МассивТокенов <> Неопределено Тогда
		ЗапросТокены = Новый Запрос();
		ЗапросТокены.Текст =
			"ВЫБРАТЬ
			|	ТокеныЛичногоКабинета.Пользователь КАК Пользователь,
			|	ТокеныЛичногоКабинета.Токен КАК Токен
			|ИЗ
			|	РегистрСведений.ТокеныЛичногоКабинета КАК ТокеныЛичногоКабинета
			|ГДЕ
			|	ТокеныЛичногоКабинета.Пользователь = &Пользователь
			|	И ТокеныЛичногоКабинета.Токен В(&МассивТокенов)";
			
		ЗапросТокены.УстановитьПараметр("Пользователь", ПользовательСсылка);
		ЗапросТокены.УстановитьПараметр("МассивТокенов", МассивТокенов);
		Выборка = ЗапросТокены.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			НачатьТранзакцию();
			Попытка							
				Набор = РегистрыСведений.ТокеныЛичногоКабинета.СоздатьНаборЗаписей();
				Набор.Отбор.Пользователь.Установить(Выборка.Пользователь);
				Набор.Отбор.Токен.Установить(Выборка.Токен);
				Набор.Записать();							
				ЗафиксироватьТранзакцию();
			Исключение
				ОтменитьТранзакцию();
			КонецПопытки;
		КонецЦикла;
		
	КонецЕсли;
	
	УдалитьУстаревшиеТокеныАвторизации();
	
	Ответ = Новый HTTPСервисОтвет(302);
	Ответ.Заголовки.Очистить();
	НовыйURL = СокрЛП(Запрос.БазовыйURL) + "/";
	Ответ.Заголовки.Вставить("Location", 			НовыйURL);
	Ответ.Заголовки.Вставить("Content-Location", 	НовыйURL);	
	Ответ.Заголовки.Вставить("Set-Cookie",			"token=;");
	
	ОбновитьПовторноИспользуемыеЗначения();
	
КонецПроцедуры

// Удалить устаревшие данные токенов авторизации пользователей.
//		
Процедура УдалитьУстаревшиеТокеныАвторизации()
	
	УстановитьПривилегированныйРежим(Истина);
	
	// Удалим устаревшие записи токенов.
	Запрос = Новый Запрос();
	Запрос.Текст =
		"ВЫБРАТЬ
		|	ТокеныЛичногоКабинета.Пользователь КАК Пользователь,
		|	ТокеныЛичногоКабинета.Токен КАК Токен,
		|	ТокеныЛичногоКабинета.СрокЖизниТокена КАК СрокЖизниТокена
		|ИЗ
		|	РегистрСведений.ТокеныЛичногоКабинета КАК ТокеныЛичногоКабинета
		|ГДЕ
		|	ТокеныЛичногоКабинета.СрокЖизниТокена < &СрокЖизниТокена";
		
	Запрос.УстановитьПараметр("СрокЖизниТокена", ТекущаяДатаСеанса());
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		НачатьТранзакцию();
		Попытка									
			Набор = РегистрыСведений.ТокеныЛичногоКабинета.СоздатьНаборЗаписей();
			Набор.Отбор.Пользователь.Установить(Выборка.Пользователь);
			Набор.Отбор.Токен.Установить(Выборка.Токен);
			Набор.Отбор.СрокЖизниТокена.Установить(Выборка.СрокЖизниТокена);
			Набор.Записать();							
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
		КонецПопытки;
	КонецЦикла;
	
КонецПроцедуры

// Возвращает авторизованного пользователя по HTTP-запросу из заголовка. 
//
// Параметры:
//	ЗаголовкиЗапроса - Соответствие - HTTP-заголовки запроса.
//
// Возвращаемое значение:
// 	СправочникСсылка.Пользователи - найденный пользователь или Неопределено, если пользователь не был найден.
//	
Функция ПолучитьАвторизованногоПользователя(Знач ЗаголовкиЗапроса) Экспорт
	
	МассивТокенов = ЗначенияCookie(ЗаголовкиЗапроса, "token");
	
	Если НЕ ЗначениеЗаполнено(МассивТокенов) Тогда
		Возврат Неопределено;
	КонецЕсли;
		
	Возврат ПолучитьПользователяВебСайтаПоТокену(МассивТокенов);
	
КонецФункции

// Получает значения Cookie из заголовков HTTP-запроса по имени переменной.
//
// Параметры:
// 	ЗаголовкиЗапроса - Соответствие - HTTP-заголовки запроса.
// 	ИмяПеременнойCookie - Строка - имя Cookie, которую хотим узнать
//
// Возвращаемое значение: 
// 	Массив - Массив строк с значениями Cookie. Если значения не найдены, то возвращается Неопределено.
//
Функция ЗначенияCookie(Знач ЗаголовкиЗапроса, Знач ИмяПеременнойCookie)	
	
	КукиСтрокой = ЗаголовкиЗапроса.Получить("Cookie");
	Если ПустаяСтрока(КукиСтрокой) Тогда
		Возврат Неопределено;
	КонецЕсли;
	МассивКуки = СтрРазделить(КукиСтрокой, ";");
	
	Значение = Новый Массив();
	
	Для Каждого Куки Из МассивКуки Цикл
		Куки = СокрЛП(Куки);
		Если СтрНайти(Куки, ИмяПеременнойCookie + "=") <> 0 Тогда
			ЗначениеКуки = СтрЗаменить(Куки, ИмяПеременнойCookie + "=", "");
			Если НЕ ПустаяСтрока(ЗначениеКуки) Тогда	
				Значение.Добавить(ЗначениеКуки);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;	
	
	Если Значение.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Значение;
    
КонецФункции


// Возвращает пользователя по токену авторизации.
//
// Параметры:
//	МассивТокенов - Массив - массив строковых токенов пользователей
//
// Возвращаемое значение:
// 	СправочникСсылка.Пользователи - найденный пользователь или Неопределено, если пользователь не был найден.
//	
Функция ПолучитьПользователяВебСайтаПоТокену(Знач МассивТокенов)
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст = 	
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	ТокеныЛичногоКабинета.Пользователь
		|ИЗ
		|	РегистрСведений.ТокеныЛичногоКабинета КАК ТокеныЛичногоКабинета
		|ГДЕ
		|	ТокеныЛичногоКабинета.Токен В(&МассивТокенов)
		|	И ТокеныЛичногоКабинета.СрокЖизниТокена > &ТекущаяДата";
	
	Запрос.УстановитьПараметр("МассивТокенов", МассивТокенов);
	Запрос.УстановитьПараметр("ТекущаяДата", ТекущаяДатаСеанса());
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Возврат Выборка.Пользователь;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Проверяет введен верный логин/пароль пользователя или нет.
//
// Параметры (название, тип, дифференцированное значение)
// 	Логин - Строка - логин пользователя
// 	Пароль - Строка - пароль пользователя
//
// Возвращаемое значение: 
//	СправочникСсылка.Пользователи - Неопределено, если пользователь не найден, или логин/пароль не подошел
//		Или ссылка на справочник пользователи, найденного пользователя.
//
Функция НайтиПользователяПоЛогинуИПаролю(Знач Логин, Знач Пароль)
	
	УстановитьПривилегированныйРежим(Истина);
	
	// Проверка по логину.
	ПользовательИнформационнойБазы = ПользователиИнформационнойБазы.НайтиПоИмени(Логин);	
	Если ПользовательИнформационнойБазы = Неопределено Тогда
	    Возврат Неопределено;
	КонецЕсли;
	
	// ToDo: Проверка по e-mail если введен он вместо логина.
	// Берем логин и проверяем есть ли он в контактах у пользователей.
	// ...
	
	// ToDo: Проверка через Active Directory
	// ...
	    
    ХэшНастоящегоПароля = ПользовательИнформационнойБазы.СохраняемоеЗначениеПароля;
    ХешВведенногоПароля = "";
    
    НачатьТранзакцию();
    Попытка
    	ПользовательИнформационнойБазы.Пароль = Пароль;
	    ПользовательИнформационнойБазы.Записать();	    
	    ХешВведенногоПароля = ПользователиИнформационнойБазы.НайтиПоИмени(Логин).СохраняемоеЗначениеПароля;
	    ОтменитьТранзакцию(); // << Тут все верно.
    Исключение
    	ОтменитьТранзакцию();
    КонецПопытки;	    			    	
    	
	// Проверка, хэшей пароля.	    
    Возврат ?(ХешВведенногоПароля = ХэшНастоящегоПароля, 
    	Справочники.Пользователи.НайтиПоРеквизиту("ИдентификаторПользователяИБ", 
    		ПользовательИнформационнойБазы.УникальныйИдентификатор),
    	Неопределено);
    
КонецФункции

// Время жизни авторизации в секундах по умолчанию.
//
// Возвращаемое значение:
//	Число - время жизни авторизации в сек.
//	
Функция ВремяЖизниАвторизацииВСекундах()
	
	Возврат 24 * 60 * 60; // 24 часа	
	
КонецФункции

#КонецОбласти

// Возвращает содержимое страницы используя относительный URL.
//
// Параметры:
//	ОтносительныйURL - Строка - адрес URL.
//
// Возвращаемое значение:
//	Строка - содержимое найденной страницы или пустая строка.
//
//@skip-warning
Функция СодержимоеСтраницы(Знач ОтносительныйURL)
	
	ИмяФайла 	= Сред(ОтносительныйURL, СтрНайти(ОтносительныйURL, "/", НаправлениеПоиска.СКонца) + 1);
	Путь 		= Лев(ОтносительныйURL, СтрДлина(ОтносительныйURL) - СтрДлина(ИмяФайла));
	
	Страница = HTTPСервисыПовтИсп.ПолучитьСтраницуОтносительногоURL(Путь, ИмяФайла);
	Если Страница <> Неопределено Тогда
		Данные 	= Страница.ХранилищеФайла.Получить(); 
		Тело 	= РаботаСHTML.ПолучитьТекстИзДвоичныхДанных(Данные);
		Возврат Тело;
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

// Объединение двоичных данных в одни двоичные данные.
//
// Параметры:
//	ДД1 - ДвоичныеДанные - что надо объединить.
//	ДД2 - ДвоичныеДанные - что надо объединить.
//	ДД3 - ДвоичныеДанные - что надо объединить.
//	ДД4 - ДвоичныеДанные - что надо объединить.
//	ДД5 - ДвоичныеДанные - что надо объединить.
//	ДД6 - ДвоичныеДанные - что надо объединить.
//	ДД7 - ДвоичныеДанные - что надо объединить.
//
// Возвращаемое значение:
//	ДвоичныеДанные - результат объединения.
//
Функция ОбъединитьДвоичныеДаннные(ДД1, ДД2, ДД3 = Неопределено, ДД4 = Неопределено, ДД5 = Неопределено, 
	ДД6 = Неопределено, ДД7 = Неопределено)
	
	Перем мФайлы, сч, ДД, мИмяФайла;
	
	мФайлы = Новый Массив;
	Для сч = 1 По 7 Цикл
		ДД = ?(сч = 1, ДД1, ?(сч = 2, ДД2, ?(сч = 3, ДД3, ?(сч = 4, ДД4, 
			?(сч = 5, ДД5, ?(сч = 6, ДД6, ?(сч = 7, ДД7, Неопределено)))))));
		Если ДД = Неопределено ИЛИ ТипЗнч(ДД) <> Тип("ДвоичныеДанные") Тогда
			Продолжить;
		ИначеЕсли ДД.Размер()<=0 Тогда
			Продолжить;
		КонецЕсли;
		мИмяФайла = ПолучитьИмяВременногоФайла();
		ДД.Записать(мИмяФайла);
		мФайлы.Добавить(мИмяФайла);
	КонецЦикла;
	
	мИмяФайла = ПолучитьИмяВременногоФайла();
	Если мФайлы.Количество() = 0 Тогда
		Возврат Неопределено;
	ИначеЕсли мФайлы.Количество() = 1 Тогда
		УдалитьФайлы(мИмяФайла);
		ДД = Новый ДвоичныеДанные(мФайлы[0]);
		УдалитьФайлы(мФайлы[0]);
		Возврат ДД;
	КонецЕсли;
	ОбъединитьФайлы(мФайлы, мИмяФайла);
	
	ДД = Новый ДвоичныеДанные(мИмяФайла);
	УдалитьФайлы(мИмяФайла);
	Для Каждого мИмяФайла из мФайлы Цикл 
		УдалитьФайлы(мИмяФайла); 
	КонецЦикла;
	
	Возврат ДД;
	
КонецФункции

// Собирает страницу и в ее теле отображает переданный текст.
//
// Параметры (название, тип, дифференцированное значение)
//	ТекстHTML - Строка - тело HTML-документа.
//	Заголовок - Строка - заголовой HTML-документа.
//	
// Возвращаемое значение: 
// 	Строка - HTML-страница.
//
Функция СобратьСтраницу(Знач ТекстHTML, Знач Заголовок = "")

	Возврат
		"<html>
		|<head>
		|	<meta charset=""utf-8"">
		|	<title>" + Заголовок + "</title>
		|</head>
		|<body>
		|" + ТекстHTML + "
		|</body>
		|</html>"
    
КонецФункции

// Возвращает языковые данные личного кабинета
//
// Возвращаемое значение: 
//	Стурктура - содержит в имени название языковой переменной, а в значении строка со значением на нужном языке.
// 
Функция ЯзыковыеДанныеЛичногоКабинета()
	
	ЯзыковыеДанные 					= Новый Структура;
	ЯзыковыеДанныеХранилище 		= HTTPСервисыПовтИсп.ПолучитьКонстанту("ЛичныйКабинетЛокализация");
	ЯзыковыеДанныеТекстоваяСтрока 	= ЯзыковыеДанныеХранилище.Получить();
	Для Индекс = 1 По СтрЧислоСтрок(ЯзыковыеДанныеТекстоваяСтрока) Цикл
		Стр = СтрПолучитьСтроку(ЯзыковыеДанныеТекстоваяСтрока, Индекс);
		Если ПустаяСтрока(Стр) Тогда
			Продолжить;
		КонецЕсли;
		ИндексРавно = СтрНайти(Стр, "=");
		Если ИндексРавно > 0 Тогда
			ЯзыковыеДанные.Вставить(Лев(Стр, ИндексРавно - 1), Сред(Стр, ИндексРавно + 1));
		КонецЕсли;			
	КонецЦикла;
	    
	Возврат ЯзыковыеДанные;
	
КонецФункции

// СтандартныеПодсистемы.ОценкаПроизводительности
Функция ЗначениеТаймера()
	
	Если ОценкаПроизводительностиВызовСервераПовтИсп.ВыполнятьЗамерыПроизводительности() Тогда
		Возврат ОценкаПроизводительности.НачатьЗамерВремени();
	КонецЕсли;

	Возврат Неопределено;
	
КонецФункции

Процедура ЗаписатьЗамер(Знач КлючеваяОперация, Знач ВремяНачала)
	
	Если ВремяНачала <> Неопределено Тогда
		ОценкаПроизводительности.ЗакончитьЗамерВремени(КлючеваяОперация, ВремяНачала);
	КонецЕсли;
	
КонецПроцедуры
// Конец СтандартныеПодсистемы.ОценкаПроизводительности

// Выполняет алгоритм страницы личного кабинета.
//
// Параметры:
//	
//
Процедура ВыполнитьАлгоритм(Тело, ИмяФайлаТела, Переменные, Запрос, Ответ, Знач ОтносительныйURL, 
	ОтносительныйURLПеренаправления, Знач ИмяФайла, Знач Путь, Знач Алгоритм, Знач ЯзыковыеДанные, Знач ЭтоPOST,
	Знач POST)
	
	Если ПустаяСтрока(Алгоритм) ТОгда
		Возврат;
	КонецЕсли;

	Попытка
		Выполнить(Алгоритм);	
	Исключение
		Тело = СобратьСтраницу(ОтносительныйURL + ":" + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()),
			НСтр("ru = 'Ошибка алгоритма'"));
	КонецПопытки;
	
КонецПроцедуры

#КонецОбласти